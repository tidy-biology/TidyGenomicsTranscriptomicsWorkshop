---
title: "Tidy genomic analyses in integration with single-cell transcriptomics"
author:
  - Michael Love, UNC-Chapel Hill^[<michaelisaiahlove at gmail.com>]
output: rmarkdown::html_vignette
bibliography: "`r file.path(system.file(package='tidyomicsWorkshop', 'vignettes'), 'tidyomics.bib')`"
vignette: >
  %\VignetteIndexEntry{Tidy genomic and transcriptomic single-cell analyses}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
```


# Genomic and transcriptomic data integration

In the single-cell vignette, we have examined expression of genes across our cells, but we
haven't considered the genomic location of the genes. In this section
we will operate on genomic location information using the *plyranges*
[@Lee2019] package, and tie this to the single cell transcriptomics
data we have been examining.

*plyranges* provides tidyverse-style functionality to genomic ranges
(GRanges objects [@Lawrence2013]) analogous to how
*tidySingleCellExperiment* provides functionality for
SingleCellExperiment objects. For an example of a workflow using
*plyranges* as part of a bulk RNA-seq analysis, see @Lee2020.

:::: {.note}
In some pipelines (e.g. using *tximeta* [@Love2020] to import bulk or
single-cell quantification data) our SingleCellExperiment or
SummarizedExperiment would already have genomic range information
attached to the rows of the object. That is, we would have information
about the starts and ends of the genes, their strand information, even
the lengths of the chromosomes and the genome build, etc.
::::

Here we load single-cell data in SingleCellExperiment object format. This data is peripheral blood mononuclear cells (PBMCs) from metastatic breast cancer patients.


```{r}
library(SingleCellExperiment)
library(ggplot2)
library(plotly)
library(dplyr)
library(colorspace)
library(dittoSeq)
library(tidySingleCellExperiment)

# load single cell RNA sequencing data
sce_obj <- tidyomicsWorkshop::sce_obj

# take a look
sce_obj
```

Before we start our integrative analysis, we will first take some
steps to add hg38 range information on our genes, matching by the gene
symbol provided on the rows of `sce_obj`. We add genes from the
*ensembldb* package [@Rainer2019] (to see how to add a particular
version of Ensembl, see the package vignette).

```{r message=FALSE}
# what our rownames look like: gene symbols
sce_obj |> rownames() |> head()

# we recommend Ensembl or GENCODE gene annotations
edb <- EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86 # hg38
g <- ensembldb::genes(edb)

#head(genome(g))
```

We can examine the first three genes and their metadata:

```{r message=FALSE}
library(plyranges)
g |> dplyr::slice(1:3)
```

Our first task is to subset `g`, the human genes, to the ones in our
SingleCellExperiment. While Ensembl IDs are unique, gene symbols are
not, so we will have to also remove any duplicate gene symbols 
(recommend working with Ensembl IDs as feature identifiers when
possible).

We subset the columns of `g` to just the `symbol` column, using the
`select()` function. *plyranges* enables us to use familiar tidy verbs
on GRanges objects, e.g. to `filter` rows or to `select` columns of
metadata attached to the ranges.

```{r}
g <- g |>

  select(symbol)

g |> dplyr::slice(1:3)
```

Now we filter the genes of our SingleCellExperiment to only those
present as rownames of `sce_obj`, and remove duplicate IDs. We then
sort by genomic location, and use the gene symbols as names of the
ranges.

```{r}
gene_names <- sce_obj |> rownames()

g <- g |>
  
  filter(symbol %in% gene_names) |>
  filter(!duplicated(symbol)) |>
  sort() # genomic position sorting

names(g) <- g$symbol
```

Now we can add our gene information to the rows of the
`sce_obj`. 

:::: {.note}
Again, these following steps would not be necessary using a
pipeline that imports quantification data to ranged objects, but it
isn't too hard to add manually. If adding ranges manually, make note
of the provenance of where you downloaded the information (Ensembl,
GENCODE or otherwise), and assign a genome build if you plan on
sharing the final object (e.g. with `genome(x) <- "..."`).
::::

```{r}
all(names(g) %in% rownames(sce_obj)) 
sce_sub <- sce_obj[ names(g), ] # put SCE in order of `g`
rowRanges(sce_sub) <- g # assign ranges `g` to the SCE
sce_sub |> rowRanges() # peek at the ranges
```

Now let's do something interesting with the gene ranges: let's see if
genes near peaks of active chromatin marks (H3K4me3 measured with
ChIP-seq) in another experiment involving PBMC have a difference in
their expression level compared to other genes.

There are many sources of epigenetic tracks, ENCODE, Roadmap,
etc. Here we will use some ENCODE [@ENCODE2012] data available in
*AnnotationHub* on Bioconductor.

:::: {.note}
We had to do a bit of book-keeping first. These peaks were in
the hg19 genome build, so we have ran the following commands (here
un-evaluated) to 'lift" the peaks to the hg38 genome build, and
provide proper sequence information.
::::

```{r eval=FALSE}
### un-evaluated code chunk ###
# AnnotationHub contains many useful genome tracks
library(AnnotationHub)
ah <- AnnotationHub()
# can be queried with keywords
query(ah, c("Peripheral_Blood","h3k4me3"))
# downloading a particular resource
peaks <- ah[["AH44823"]]
library(rtracklayer)
# lifting hg19 to hg38
# Download https://hgdownload.soe.ucsc.edu/gbdb/hg19/liftOver/hg19ToHg38.over.chain.gz
new_peaks <- unlist(
  liftOver(
    peaks,
    chain = import.chain("~/Downloads/hg19ToHg38.over.chain")
  )
)
# Ensembl-style chrom names
seqlevelsStyle(new_peaks) <- "NCBI"
# bring over any missing chroms
seqlevels(new_peaks) <- seqlevels(sce_sub)
# bring over chrom lengths
seqinfo(new_peaks) <- seqinfo(sce_sub)
# subset to a few columns
pbmc_h3k4me3_hg38 <- new_peaks |>
  select(signalValue, qValue, peak)
# save for reloading below
save(pbmc_h3k4me3_hg38, file="data/pbmc_h3k4me3_hg38.rda", compress="xz")
```

Loading those peaks.

```{r}
# loading those H3K4me3 peaks for PBMCs
peaks <- tidyomicsWorkshop::pbmc_h3k4me3_hg38
plot(peaks$qValue, type="l", ylab="q-value", main="H3K4me3 peaks")
abline(v=5000, lty=2)
```

We will arbitrarily chose to take the top 5,000 peaks by p-value. How
to chose the number of epigenetic peaks and genes to consider in a
multi-omics analysis is a more involved question, and is worth
considering the impact of such a choice for enrichment analysis.

```{r}
peaks <- peaks |>
  
  dplyr::slice(1:5000) |> # ordered already by p-value (most to least sig)
  sort() # genomic position sorting
```

It is easy to compute the distance of the genes in our
SingleCellExperiment to the nearest H3K4me3 peak, using *plyranges*
convenience functions.

See the 
[plyranges package website](https://sa-lee.github.io/plyranges/reference/index.html) 
for a full listing of such functions.

```{r}
dists <- 
  rowRanges(sce_sub) |>
  anchor_5p() |> # anchor 5 prime end
  mutate(width=1) |> # shrink range to 1bp
  add_nearest_distance(peaks)
```

```{r}
hist(log10(dists$distance + 1), breaks=40,
     main="gene-to-peak distance", xlab="log10 distance")
```

Let's put the genes into 4 different bins by their distance to a
H3K4me3 peak: 1) overlapping [distance of 0], 2) 1bp-10kb, 
3) 10kb-100kb, or 4) farther than 100kb.

```{r}
library(tibble)
bins <- c(0,1,1e4,1e5,Inf)

dists <- dists |>
  
  select(symbol, distance, .drop_ranges = TRUE) |> # remove chr/pos/strand etc.
  as_tibble() |>
  mutate(distance_bin = cut(distance, bins, include.lowest = TRUE)) |>
  rename(feature = symbol) # this will help us add information to the SCE
```

We can see how many genes are in which category:

```{r}
dists |>
  
  ggplot(aes(distance_bin)) +
  geom_bar()
```

We will now take the SingleCellExperiment data and compress it down to
a SummarizedExperiment using the `aggregate_cells` function from
*tidySingleCellExperiment*. After this function, every column of the
SummarizedExperiment is a cell type.

We immediately pipe the SummarizedExperiment into a `left_join` where
we add the distance-to-peak information, and then into a `nest`
command where we create a nested (tidy)SummarizedExperiment object,
where we have grouped by the distance bin that the genes fall into.


```{r message=FALSE}
library(tidySummarizedExperiment)
library(purrr)
nested <- sce_sub |>
  
  aggregate_cells(cell_type) |>
  left_join(dists, by="feature") |>
  nest(se = -distance_bin)

nested
```

We can now operate on the SummarizedExperiment objects that are within
`nested`. For example, we can extract the column means of the counts
(cell-type-specific means of counts over genes).

We save this as a new tibble called `smry` as it contains summary
information.

```{r}
smry <- nested |>

  mutate(summary = map(se, \(se) {
    tibble(count_mean = colMeans(assay(se)),                             
           cell_type = se$cell_type)
  })
  ) |>
  select(-se) |>
  unnest(summary) |>
  mutate(cell = substr(cell_type, 1, 13)) # abbreviate cell_type for plot
```

As a final plot, we can look at the mean count over the genes in a
particular distance bin (x-axis), across the cell types (y-axis). The
different lines show how the genes' proximity to H3K4me3 peaks affects
the average count.

```{r}
library(forcats)
smry |>
  
  mutate(cell = fct_reorder(cell, count_mean, .fun=median)) |>
  ggplot(aes(count_mean, cell, color=distance_bin, group=distance_bin)) +
  geom_point() +
  geom_line(orientation="y") +
  xlab("mean of count over genes in bin") +
  ylab("cell type")
```

We finish this section with a re-cap of the steps we took:

1. calculated distances from genes to H3K4me3 peaks
2. added distance information onto the SingleCellExperiment
3. condensed the dataset via pseudobulking
4. computed the mean count (over genes) within 4 bins of genes
5. visualized these mean counts over cell types

Let's consider a number of issues with this first-pass analysis and
visualization:

1. we arbitrarily thresholded the peaks at the beginning of the
   analysis to take the top 5,000
2. we just computed the mean count, not taking into account total
   reads per cell type (sequencing depth per cell x number of cells) 
3. we are comparing cell-type-specific expression to aggregate
   ChIP-seq peaks in PBMC
4. the two experiments, while both PBMC, come from different projects,
   different labs, and one is from cancer patients, while the other is
   from the ENCODE project
5. we only plot the mean count over genes, perhaps it would be better
   to show more information about the distribution

:::: {.note}
As an alternative to (1), we could have counted the number of peaks
that were near each genes, or even computed on the metadata of the
peaks (signal value, etc.). An example follows of how we could have
counted overlaps instead (how many peaks within 20kb).
::::

```{r}
overlaps <- rowRanges(sce_sub) |>
 
  anchor_5p() |>
  mutate(width=1) %>%
  mutate(num_overlaps = count_overlaps(., peaks, maxgap=2e4))

table(overlaps$num_overlaps)
```

:::: {.note}
Another question that often arises is whether the distances or
overlaps we observe are more or less than we would expect if there
were no relationship between the positions of genes and peaks.
To answer questions like these, we have developed the *nullranges*
package, which allows for either bootstrapping of ranges throughout
the genome [@Mu2023], or selection of a covariate-matched background
set [@Davis2023], to  compute probabilities under the null hypothesis.
A brief example follows of bootstrapping some of the peaks in a window
of chr1:20Mb-30Mb (see *nullranges* website for more comprehensive
examples).
::::

```{r}
library(nullranges)

# make a small range for demonstration of bootstrapping
seg <- data.frame(seqnames=1, start=20e6, width=10e6) |>
  as_granges()

# generate a genome segmentation from this one range
seg <- oneRegionSegment(seg, seqlength=seqlengths(peaks)[[1]])
seg

# bootstrap peaks within this segment (just for demo)
peaks |>
  filter_by_overlaps(seg[2]) |>
  bootRanges(blockLength=1e6, seg=seg, R=10)

# these bootstrapped ranges could then be used for computing
# generic test statistics, with the `iter` column used for
# building a null distribution
```

**Session Information**

```{r}
sessionInfo()
```

**References**

```{css echo=FALSE}
.note {
  margin: 30px;
  padding: 1em;
  background: #FFF8F0;
  border: 1px solid #EFE8E0;
  border-radius: 10px;
}
```
